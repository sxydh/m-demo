概述
    Scala基于JVM运行，编译文件是Class文件，但是有自己的编译器。
    Scala将面向对象和函数式编程的特性结合在一起，是静态类型编程语言。
    Scala可以调用JDK类库
变量和数据类型
    Scala中的一切数据都是对象，都是Any的子类。
    Scala中数据类型分为两大类：数值类型（AnyVal）、引用类型（AnyRef），不管是值类型还是引用类型都是对象。
        数据类型仍然遵守：低精度的值类型向高精度值类型自动转换（隐式转换）。
        StringOps是数值类型，是对Java中的String增强。
        Unit是数值类型，只有一个实例，写作()。用于方法返回值的位置，表示方法没有返回值。对应Java中的Void。
        Null是引用类型，只有一个实例，写作null。
        Nothing是任何其它类型的子类型，如果函数没有正常的返回值（比如异常），可以用Nothing来指定返回类型。
    参考scala-demo/src/main/scala
运算符
    运算符的本质是对象的方法调用
    参考scala-demo/src/main/scala
流程控制
    参考scala-demo/src/main/scala
函数
    概述
        函数是完成某一功能的程序语句的集合。函数不是方法，方法是类中的函数，Scala方法与Java类似。
        Scala函数是一个对象（继承了Trait类）
        Scala函数可以在任何地方声明
        Scala函数没有重载或重写的概念
    函数基础
        声明格式：def <函数名称>([参数列表])[返回类型]<函数体>。
            参数列表格式：<参数名称>: <参数类型>[*][ = 参数默认值]。
                [*]表示可变参数，可变参数只能放在参数列表的最后位置。
                带默认值的参数一般放在参数列表后面
                可变参数和带默认值参数只能二选一
                实参顺序和形参顺序可以不一致，但实参需要显示指明参数名称。
            返回类型格式：[: 类型] =。
                如果类型可以进行推导，则可以省略。
                如果函数没有返回值，返回类型可以省略或者用Unit表示。
            函数体格式：{ <语句> }。
                如果只有一条语句，括号可以省略。
    函数进阶 
        函数可以作为值进行传递。例如：
            函数作为实参传入
            函数作为返回值返回
            函数赋值给另外一个类型为函数的变量
        函数闭包：如果一个函数，访问到了它的外部（局部）变量的值，那么这个函数和它所处的环境，称为闭包。
        函数柯里化：把一个参数列表的多个参数，变成多个参数列表。例如：f(a, b, c)柯里化后，变为f(a)(b)(c)。柯里化的一个好处：可以复用函数过程。
        传名参数：当参数类型用=>修饰时，该参数就是传名参数，传名参数值的计算过程会延迟，直到对该参数显示使用。传名参数相当于传的不是值，而是该值计算过程的代码块。
        惰性加载：当变量用lazy修饰时，该变量会被惰性加载。例如：将函数的返回值赋值给惰性加载变量，赋值时函数不会被执行，而是等该变量被显示使用时，函数才会被执行。
    至简原则
        如果函数空参，调用时括号可以省略。
        如果函数没有返回值，可以省略等号。
        如果函数返回类型显示声明为Unit，则关键字return不起作用。
        如果函数显示调用return，则必须显示指定返回类型。
        如果函数返回类型可以推导，则可以省略。
        如果函数体只有一行，则可以省略括号。
        函数体关键字return可以省略，默认最后一行作为返回值。
    
        对于匿名函数
            如果形参类型可以进行推导，则可以省略。
            如果只有一个参数，则可以省略括号。
            如果参数只用到一次，则可以用_代替，并省略参数列表。
    参考scala-demo/src/main/scala
包
    包声明
        第一种方式：一个源文件一个包名，和Java的包管理风格相同。
        第二种方式：一个源文件中可以声明多个package，子包内可以访问父包中的内容，而无需导包。
    包对象
        Scala中可以为每个包定义一个同名的包对象，定义在该包对象中的成员，可以作为该包下所有Class和Object的共享变量，直接被访问。
    包导入
        文件顶部导入：文件内都可以使用。
        局部导入：作用范围内可以使用。
        多个类导入：import java.util.{HashSet => set, ArrayList}，=>可以用来起别名。
        通配符导入：import java.util._。
        屏蔽导入：import java.util.{HashSet => _, _}，除了HashSet，其余的都导入。
    参考scala-demo/src/main/scala
类和对象
    一个scala文件，可以写多个类（不同于Java，Scala中没有关键字public，默认public）。
    参考scala-demo/src/main/scala
封装
    访问权限
        public：Scala中属性和方法的访问权限默认是public，但是没有public关键字。
            public属性底层实际是private的，并通过get和set方法对其进行操作（不同于Java，需要显示声明私有属性的get和set方法）。为了兼容一些框架对get和set方法的调用，可以在属性上加@BeanProperty注解。
        private[包名]：私有权限，包名是可选的，类的内部/伴生对象/指定包下的类可以访问。
        protected：受保护权限，同类/子类可以访问。
    方法
        Scala的方法与Java类似
    构造器
        Scala的构造器包括主构造器和辅构造器
        主构造器形参有三种修饰符
            没有任何修饰符：参数就是一个局部变量。
            var修饰符：参数是类的成员属性，可以修改。
            val修饰符：参数是类的只读成员属性，不可以修改。
        辅构造器可以有多个
        辅构造器需要显示调用主构造器
    参考scala-demo/src/main/scala
继承和多态
    Scala的继承和多态，与Java类似。
抽象类
    抽象属性：成员属性没有初始化，该属性就是抽象属性。
        子类实现抽象属性的初始化，父类属性可以用var修饰。
        子类重写非抽象属性，父类属性需要用val修饰。
    抽象方法：与Java类似。
        子类重写抽象方法可以不加override，但是重写非抽象方法需要加。
    匿名子类：与Java类似。
    参考scala-demo/src/main/scala
单例对象
    Scala没有静态的概念（没有static关键字），但是为了和Java交互，就产生了一种特殊的对象来模拟类对象，该对象为单例对象。
        单例对象用object关键字声明
    若单例对象名与类名一致，则称该单例对象是这个类的伴生对象，这个类是单例对象的伴生类。
    类的所有“静态属性”都可以放在伴生对象中声明
    参考scala-demo/src/main/scala
特质
    概述
        Scala采用特质（Trait）来代替Java接口的概念，也就是说，如果多个类具有相同的特质（特征）时，就可以将这个特质（特征）独立出来，采用关键字trait声明。
        Trait既可以有抽象属性和方法，也可以有具体的属性和方法。
        一个类可以混入（Mixin）多个特质
        Scala引入特质（Trait），一是可以代替Java接口，而是对单继承机制的补充。
    特质叠加
        由于一个类可以混入（Mixin）多个Trait，且Trait中可以有具体的属性和方法，若混入的特质中具有完全相同的方法，必然会出现继承冲突问题。
        冲突分为两种
            第一种：一个类（Sub）混入的两个Trait（TraitA，TraitB）具有相同的具体方法，且两个Trait之间没有任何关系，解决这类冲突问题，可以直接在类（Sub）中重写冲突方法。
            第二种：一个类（Sub）混入的两个Trait（TraitA，TraitB）具有相同的具体方法，且两个Trait继承自相同的Trait（TraitC），即所谓的钻石问题，解决这类冲突问题，Scala采用了特质叠加的策略。
    特质自身类型
        自身类型可以实现依赖注入
    参考scala-demo/src/main/scala
集合
    概述
        Scala所有的集合继承自Iterable特质
    数组
    List
    Set
    Map
    元组
    参考scala-demo/src/main/scala
异常
    Scala异常与Java类似，但是Scala没有受检异常。
    参考scala-demo/src/main/scala
隐式转换
    概述
        当编译器第一次编译失败的时候，会在当前环境中查找能让代码编译通过的方法，用于将类型进行转换，实现二次编译。
    隐式函数
        隐式函数可以在不改任何代码的情况下，扩展某个类的功能。
    隐式参数
        编译器按照隐式参数的类型去寻找对应类型的隐式值，与隐式值的名称无关。
        同一个作用域，相同类型的隐式值只能有一个。
        隐式参数优先于默认参数
    隐式类 
        隐式类可以扩展类的功能，在集合中隐式类会发挥重要的作用。
        隐式类的构造参数有且只有一个
        隐式类必须被定义在类或伴生对象或包对象里，即隐式类位置不能在顶部。
    隐式查找机制
        首先在当前代码作用域查找隐式实体（隐式函数，隐式类，隐式对象）
        如果查找不到，会继续在隐式参数的类型的作用域里查找
            类型的作用域是指与该类型相关联的全部伴生对象，以及该类型所在包的包对象。
    参考scala-demo/src/main/scala
泛型
    协变：TypeName[+T]。
        Son是Father的子列，则TypeName[Son]是TypeName[Father]的子类。
    逆变：TypeName[-T]。
        Son是Father的子列，则TypeName[Son]是TypeName[Father]的父类。
    不变：TypeName[T]。
        Son是Father的子列，则TypeName[Son]与TypeName[Father]没有父子关系。
    上限：TypeName[T <: SuperName]。
    下限：TypeName[T >: SubName]。
环境
    Maven
        Scala SDK
    IDEA
        Scala Plugin